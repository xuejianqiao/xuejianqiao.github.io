---
layout: post
title: Redis面试常见的问题
category: 中间件
tags: Redis,redis
keywords: 
description:
---


#### 1.redis 简介 &#x2753;
#### 2.为什么要用 redis /为什么要用缓存 &#x2753;
#### 3.为什么要用 redis 而不用 map/guava 做缓存  &#x2753;
#### 4.redis 和 memcached 的区别 &#x2753;
#### 5.redis 常见数据结构以及使用场景分析 &#x2753;
#### 6.redis 设置过期时间 &#x2753;
#### 7.redis 内存淘汰机制 &#x2753;
#### 8.redis 持久化机制（怎么保证 redis 挂掉之后再重启数据可以进行恢复） &#x2753;
#### 9.缓存雪崩和缓存穿透问题解决方案 &#x2753;
#### 10.如何解决 Redis 的并发竞争 Key 问题 &#x2753;
#### 11.如何保证缓存与数据库双写时的数据一致性？&#x2753;


### 一.redis简介 

简单来说redis就是一个数据库，不过与传统数据库不同的是redis的数据是存在内存当中的，所以存写速度非常快，因此redis被广泛用于缓存方向。另外，redis也经常用来做分布式锁。redis提供了多种数据类型来支持不同的业务场景。除此之外，redis支持事物，持久化，LUA脚本，LRU驱动事件，多种集群方案。

### 二.为什么要用 redis /为什么要用缓存
主要从 "高性能" 和 "高并发" 这两点来看待这个问题。

高性能：
假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！

高并发：
在访问量巨大的时候，数据库的IO会是个很大的瓶颈，减少数据库的访问压力

### 三.为什么要用 redis 而不用 map/guava 做缓存?
 
redis是分布式缓存，而map/guava属于本地缓存

### 四.redis 和 memcached 的区别
 1.redis 支持更丰富的数据类型（支持更复杂的应用场景）：redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。
 
 2.Redis 支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载使用，而memcached 把数据全部存在内存当中去。
 
 3.集群模式：memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是redis目前是原生支持cluster模式的，redis官方就是支持redis cluster集群模式的，比memcached来说要更好。
 
 4、memcached 是多线程 ,非阻塞Io复用的网络模型；redis 使用单线程的多路IO复用模型。
 
 
### 五.redis 常见数据结构以及使用场景分析
 1.string:
 > 常用命令：set,get,decr,incr,mget 等。
 
 string 数据结构简单的key-value 类型，value其实不仅仅是string，也可以是数字。常规 key-value 缓存应用；
 
 2.Hash:
 > 常用命令： hget,hset,hgetall 等。
 
 Hash是一个string类型的filld 和value的映射表，hash特别适合用于存储对象，后续操作的时候，你可以仅仅修改这个对象中的某个字段的值。比如我们可以hash数据结构来存储用户信息，商品信息等。
 
 3.List
 > 常用命令: lpush,rpush,lpop,rpop,lrange等
 
 list 就是链表，Redis 的应用场景非常多，也是redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用redis 的list 结构来实现
 
 4.Set
 > 常用命令：sadd,spop,smembers,sunion 等。
 
 set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的。
 
 当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供某个成员是否在一个set集合内的重要接口，这是list所不能提供的。可以基于set轻易实现交集，并集，差集的操作。
 比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，

5.Sorted Set
> 常用命令： zadd,zrange,zrem,zcard等

和set相比，sorted set增加了一个权重的参数score，使得集合中的元素能够按照score进行有序排列。

在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息,适合使用redis中的sortedset 结构进行存储。

### 六.redis 设置过期时间
Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的token或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。

如果假设你设置一个一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？

定期删除+惰性删除。
> * 定期删除：redis默认是每隔 100ms 就随机抽取一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！ 
> * 惰性删除 ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！

### 七.redis 内存淘汰机制
redis 提供 6种数据淘汰策略：
> * volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰
> * volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
> * volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
> * allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）.
> * allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
> * no-enviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！

### 八.redis 持久化机制
Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。Redis的一种持久化方式叫快照（snapshotting，RDB）,另一种方式是只追加文件（append-only file,AOF）.这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。

> 快照（snapshotting）持久化（RDB）:

Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。

快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：

> * save 900 1              #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

> * save 300 10            #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

> * save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

.

> AOF（append-only file）持久化

与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：

> appendonly yes

开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。

在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：

> appendfsync always     #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no      #让操作系统决定何时进行同步

为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。

### 九.缓存雪崩和缓存穿透问题解决方案

缓存雪崩：
简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。
> * 事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。
> * 事中：本地ehcache缓存 + hystrix限流&降级，避免MySQL崩掉
> * 事后：利用 redis 持久化机制保存的数据尽快恢复缓存

缓存穿透:
简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。

解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。


### 十.如何解决 Redis 的并发竞争 Key 问题

所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！

推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）

基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。

在实践中，当然是从以可靠性为主。所以首推Zookeeper。


### 十一.如何保证缓存与数据库双写时的数据一致性？

你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？

一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况

串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。



### 十二.其他

Redis回收进程如何工作的? Redis回收使用的是什么算法?

https://www.cnblogs.com/WJ5888/p/4371647.html

Redis 大量数据插入
http://www.redis.cn/topics/mass-insert.html

Redis 分区的优势、不足以及分区类型

官方文档提供的讲解：http://www.redis.net.cn/tutorial/3524.html

Redis持久化数据和缓存怎么做扩容？
https://blog.csdn.net/tr1912/article/details/70197085?foxhandler=RssReadRenderProcessHandler

Redis与消息队列
https://www.zhihu.com/question/20795043/answer/345073457